.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Tradition::Collation::RelationshipStore 3"
.TH Text::Tradition::Collation::RelationshipStore 3 "2013-08-10" "perl v5.16.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Tradition::Collation::RelationshipStore \- Keeps track of the relationships
between readings in a given collation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::Tradition is a library for representation and analysis of collated
texts, particularly medieval ones.  The RelationshipStore is an internal object
of the collation, to keep track of the defined relationships (both specific and
general) between readings.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "new( collation => $collation );"
.el .SS "new( collation => \f(CW$collation\fP );"
.IX Subsection "new( collation => $collation );"
Creates a new relationship store for the given collation.
.SS "types"
.IX Subsection "types"
Registry of possible relationship types. See RelationshipType for more info.
.SS "\fIequivalence_graph()\fP"
.IX Subsection "equivalence_graph()"
Returns an equivalence graph of the collation, in which all readings
related via a 'colocated' relationship are transformed into a single
vertex. Can be used to determine the validity of a new relationship.
.SS "get_relationship"
.IX Subsection "get_relationship"
Return the relationship object, if any, that exists between two readings.
.SS "create"
.IX Subsection "create"
Create a new relationship with the given options and return it.
Warn and return undef if the relationship cannot be created.
.ie n .SS "add_scoped_relationship( $rel )"
.el .SS "add_scoped_relationship( \f(CW$rel\fP )"
.IX Subsection "add_scoped_relationship( $rel )"
Keep track of relationships defined between specific readings that are scoped
non-locally.  Key on whichever reading occurs first alphabetically.
.ie n .SS "scoped_relationship( $reading_a, $reading_b )"
.el .SS "scoped_relationship( \f(CW$reading_a\fP, \f(CW$reading_b\fP )"
.IX Subsection "scoped_relationship( $reading_a, $reading_b )"
Returns the general (document-level or global) relationship that has been defined 
between the two reading strings. Returns undef if there is no general relationship.
.ie n .SS "add_relationship( $self, $source, $sourcetext, $target, $targettext, $opts )"
.el .SS "add_relationship( \f(CW$self\fP, \f(CW$source\fP, \f(CW$sourcetext\fP, \f(CW$target\fP, \f(CW$targettext\fP, \f(CW$opts\fP )"
.IX Subsection "add_relationship( $self, $source, $sourcetext, $target, $targettext, $opts )"
Adds the relationship specified in \f(CW$opts\fR (see Text::Tradition::Collation::Relationship 
for the possible options) between the readings given in \f(CW$source\fR and \f(CW$target\fR.  Sets
up a scoped relationship between \f(CW$sourcetext\fR and \f(CW$targettext\fR if the relationship is
scoped non-locally.
.PP
Returns a status boolean and a list of all reading pairs connected by the call to
add_relationship.
.ie n .SS "add_global_relationship( $options, $skipvector )"
.el .SS "add_global_relationship( \f(CW$options\fP, \f(CW$skipvector\fP )"
.IX Subsection "add_global_relationship( $options, $skipvector )"
Adds the relationship specified wherever the relevant readings appear together 
in the graph.  Options as in add_relationship above.
.ie n .SS "del_scoped_relationship( $reading_a, $reading_b )"
.el .SS "del_scoped_relationship( \f(CW$reading_a\fP, \f(CW$reading_b\fP )"
.IX Subsection "del_scoped_relationship( $reading_a, $reading_b )"
Returns the general (document-level or global) relationship that has been defined 
between the two reading strings. Returns undef if there is no general relationship.
.ie n .SS "del_relationship( $source, $target, $allscope )"
.el .SS "del_relationship( \f(CW$source\fP, \f(CW$target\fP, \f(CW$allscope\fP )"
.IX Subsection "del_relationship( $source, $target, $allscope )"
Removes the relationship between the given readings. If the relationship is
non-local and \f(CW$allscope\fR is true, removes the relationship throughout the 
relevant scope.
.ie n .SS "relationship_valid( $source, $target, $type )"
.el .SS "relationship_valid( \f(CW$source\fP, \f(CW$target\fP, \f(CW$type\fP )"
.IX Subsection "relationship_valid( $source, $target, $type )"
Checks whether a relationship of type \f(CW$type\fR may exist between the readings given
in \f(CW$source\fR and \f(CW$target\fR.  Returns a tuple of ( status, message ) where status is
a yes/no boolean and, if the answer is no, message gives the reason why.
.ie n .SS "verify_or_delete( $reading1, $reading2 ) {"
.el .SS "verify_or_delete( \f(CW$reading1\fP, \f(CW$reading2\fP ) {"
.IX Subsection "verify_or_delete( $reading1, $reading2 ) {"
Given the existing relationship at ( \f(CW$reading1\fR, \f(CW$reading2\fR ), make sure it is
still valid. If it is not still valid, delete it. Use this only to check
non-colocated relationships!
.ie n .SS "related_readings( $reading, $filter )"
.el .SS "related_readings( \f(CW$reading\fP, \f(CW$filter\fP )"
.IX Subsection "related_readings( $reading, $filter )"
Returns a list of readings that are connected via direct relationship links
to \f(CW$reading\fR. If \f(CW$filter\fR is set to a subroutine ref, returns only those
related readings where \f(CW$filte\fRr( \f(CW$relationship\fR ) returns a true value.
.ie n .SS "propagate_relationship( $rel )"
.el .SS "propagate_relationship( \f(CW$rel\fP )"
.IX Subsection "propagate_relationship( $rel )"
Apply the transitivity and binding level rules to propagate the consequences of
the specified relationship link, ensuring all consequent relationships exist.
For now, we only propagate colocation links if we are passed a colocation, and
we only propagate displacement links if we are given a displacement.
.PP
Returns an array of tuples ( rdg1, rdg2, type ) for each new reading set.
.SS "propagate_all_relationships"
.IX Subsection "propagate_all_relationships"
Apply propagation logic retroactively to all relationships in the tradition.
.ie n .SS "merge_readings( $kept, $deleted );"
.el .SS "merge_readings( \f(CW$kept\fP, \f(CW$deleted\fP );"
.IX Subsection "merge_readings( $kept, $deleted );"
Makes a best-effort merge of the relationship links between the given readings, and
stops tracking the to-be-deleted reading.
.SS "add_equivalence_edge"
.IX Subsection "add_equivalence_edge"
Add an edge in the equivalence graph corresponding to \f(CW$source\fR \-> \f(CW$target\fR in the
collation. Should only be called by Collation.
.SS "delete_equivalence_edge"
.IX Subsection "delete_equivalence_edge"
Remove an edge in the equivalence graph corresponding to \f(CW$source\fR \-> \f(CW$target\fR in the
collation. Should only be called by Collation.
.SS "test_equivalence"
.IX Subsection "test_equivalence"
Test whether, if two readings were equated with a 'colocated' relationship, 
the graph would still be valid.
.SS "rebuild_equivalence"
.IX Subsection "rebuild_equivalence"
(Re)build the equivalence graph from scratch. Dumps the graph, makes a new one,
adds all readings and edges, then makes an equivalence for all relationships.
.SS "equivalence_ranks"
.IX Subsection "equivalence_ranks"
Rank all vertices in the equivalence graph, and return a hash reference with
vertex => rank mapping.
