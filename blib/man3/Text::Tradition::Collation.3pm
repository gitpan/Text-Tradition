.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Text::Tradition::Collation 3"
.TH Text::Tradition::Collation 3 "2013-08-10" "perl v5.16.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Text::Tradition::Collation \- a software model for a text collation
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&  use Text::Tradition;
\&  my $t = Text::Tradition\->new( 
\&    \*(Aqname\*(Aq => \*(Aqthis is a text\*(Aq,
\&    \*(Aqinput\*(Aq => \*(AqTEI\*(Aq,
\&    \*(Aqfile\*(Aq => \*(Aq/path/to/tei_parallel_seg_file.xml\*(Aq );
\&
\&  my $c = $t\->collation;
\&  my @readings = $c\->readings;
\&  my @paths = $c\->paths;
\&  my @relationships = $c\->relationships;
\&  
\&  my $svg_variant_graph = $t\->collation\->as_svg();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Text::Tradition is a library for representation and analysis of collated
texts, particularly medieval ones.  The Collation is the central feature of
a Tradition, where the text, its sequence of readings, and its relationships
between readings are actually kept.
.SH "CONSTRUCTOR"
.IX Header "CONSTRUCTOR"
.SS "new"
.IX Subsection "new"
The constructor.  Takes a hash or hashref of the following arguments:
.IP "\(bu" 4
tradition \- The Text::Tradition object to which the collation 
belongs. Required.
.IP "\(bu" 4
linear \- Whether the collation should be linear; that is, whether 
transposed readings should be treated as two linked readings rather than one, 
and therefore whether the collation graph is acyclic.  Defaults to true.
.IP "\(bu" 4
baselabel \- The default label for the path taken by a base text 
(if any). Defaults to 'base text'.
.IP "\(bu" 4
wit_list_separator \- The string to join a list of witnesses for 
purposes of making labels in display graphs.  Defaults to ', '.
.IP "\(bu" 4
ac_label \- The extra label to tack onto a witness sigil when 
representing another layer of path for the given witness \- that is, when
a text has more than one possible reading due to scribal corrections or
the like.  Defaults to ' (a.c.)'.
.IP "\(bu" 4
wordsep \- The string used to separate words in the original text.
Defaults to ' '.
.SH "ACCESSORS"
.IX Header "ACCESSORS"
.SS "tradition"
.IX Subsection "tradition"
.SS "linear"
.IX Subsection "linear"
.SS "wit_list_separator"
.IX Subsection "wit_list_separator"
.SS "baselabel"
.IX Subsection "baselabel"
.SS "ac_label"
.IX Subsection "ac_label"
.SS "wordsep"
.IX Subsection "wordsep"
Simple accessors for collation attributes.
.SS "start"
.IX Subsection "start"
The meta-reading at the start of every witness path.
.SS "end"
.IX Subsection "end"
The meta-reading at the end of every witness path.
.SS "readings"
.IX Subsection "readings"
Returns all Reading objects in the graph.
.ie n .SS "reading( $id )"
.el .SS "reading( \f(CW$id\fP )"
.IX Subsection "reading( $id )"
Returns the Reading object corresponding to the given \s-1ID\s0.
.ie n .SS "add_reading( $reading_args )"
.el .SS "add_reading( \f(CW$reading_args\fP )"
.IX Subsection "add_reading( $reading_args )"
Adds a new reading object to the collation. 
See Text::Tradition::Collation::Reading for the available arguments.
.ie n .SS "del_reading( $object_or_id )"
.el .SS "del_reading( \f(CW$object_or_id\fP )"
.IX Subsection "del_reading( $object_or_id )"
Removes the given reading from the collation, implicitly removing its
paths and relationships.
.ie n .SS "has_reading( $id )"
.el .SS "has_reading( \f(CW$id\fP )"
.IX Subsection "has_reading( $id )"
Predicate to see whether a given reading \s-1ID\s0 is in the graph.
.ie n .SS "reading_witnesses( $object_or_id )"
.el .SS "reading_witnesses( \f(CW$object_or_id\fP )"
.IX Subsection "reading_witnesses( $object_or_id )"
Returns a list of sigils whose witnesses contain the reading.
.SS "paths"
.IX Subsection "paths"
Returns all reading paths within the document \- that is, all edges in the 
collation graph.  Each path is an arrayref of [ \f(CW$source\fR, \f(CW$target\fR ] reading IDs.
.ie n .SS "add_path( $source, $target, $sigil )"
.el .SS "add_path( \f(CW$source\fP, \f(CW$target\fP, \f(CW$sigil\fP )"
.IX Subsection "add_path( $source, $target, $sigil )"
Links the given readings in the collation in sequence, under the given witness
sigil.  The readings may be specified by object or \s-1ID\s0.
.ie n .SS "del_path( $source, $target, $sigil )"
.el .SS "del_path( \f(CW$source\fP, \f(CW$target\fP, \f(CW$sigil\fP )"
.IX Subsection "del_path( $source, $target, $sigil )"
Links the given readings in the collation in sequence, under the given witness
sigil.  The readings may be specified by object or \s-1ID\s0.
.ie n .SS "has_path( $source, $target );"
.el .SS "has_path( \f(CW$source\fP, \f(CW$target\fP );"
.IX Subsection "has_path( $source, $target );"
Returns true if the two readings are linked in sequence in any witness.  
The readings may be specified by object or \s-1ID\s0.
.SS "relationships"
.IX Subsection "relationships"
Returns all Relationship objects in the collation.
.ie n .SS "add_relationship( $reading, $other_reading, $options )"
.el .SS "add_relationship( \f(CW$reading\fP, \f(CW$other_reading\fP, \f(CW$options\fP )"
.IX Subsection "add_relationship( $reading, $other_reading, $options )"
Adds a new relationship of the type given in \f(CW$options\fR between the two readings,
which may be specified by object or \s-1ID\s0.  Returns a value of ( \f(CW$status\fR, \f(CW@vectors\fR)
where \f(CW$status\fR is true on success, and \f(CW@vectors\fR is a list of relationship edges
that were ultimately added.
See Text::Tradition::Collation::Relationship for the available options.
.ie n .SS "merge_readings( $main, $second, $concatenate, $with_str )"
.el .SS "merge_readings( \f(CW$main\fP, \f(CW$second\fP, \f(CW$concatenate\fP, \f(CW$with_str\fP )"
.IX Subsection "merge_readings( $main, $second, $concatenate, $with_str )"
Merges the \f(CW$second\fR reading into the \f(CW$main\fR one. If \f(CW$concatenate\fR is true, then
the merged node will carry the text of both readings, concatenated with either
\&\f(CW$with_str\fR (if specified) or a sensible default (the empty string if the
appropriate 'join_*' flag is set on either reading, or else \f(CW$self\fR\->wordsep.)
.PP
The first two arguments may be either readings or reading IDs.
.SS "compress_readings"
.IX Subsection "compress_readings"
Where possible in the graph, compresses plain sequences of readings into a
single reading. The sequences must consist of readings with no
relationships to other readings, with only a single witness path between
them and no other witness paths from either that would skip the other. The
readings must also not be marked as nonsense or bad grammar.
.PP
\&\s-1WARNING:\s0 This operation cannot be undone.
.ie n .SS "duplicate_reading( $reading, @witlist )"
.el .SS "duplicate_reading( \f(CW$reading\fP, \f(CW@witlist\fP )"
.IX Subsection "duplicate_reading( $reading, @witlist )"
Split the given reading into two, so that the new reading is in the path for
the witnesses given in \f(CW@witlist\fR. If the result is that certain non-colocated
relationships (e.g. transpositions) are no longer valid, these will be removed.
Returns the newly-created reading.
.ie n .SS "clear_witness( @sigil_list )"
.el .SS "clear_witness( \f(CW@sigil_list\fP )"
.IX Subsection "clear_witness( @sigil_list )"
Clear the given witnesses out of the collation entirely, removing references
to them in paths, and removing readings that belong only to them.  Should only
be called via \f(CW$tradition\fR\->del_witness.
.ie n .SS "reading_witnesses( $reading )"
.el .SS "reading_witnesses( \f(CW$reading\fP )"
.IX Subsection "reading_witnesses( $reading )"
Return a list of sigils corresponding to the witnesses in which the reading appears.
.SH "OUTPUT METHODS"
.IX Header "OUTPUT METHODS"
.SS "as_svg( \e%options )"
.IX Subsection "as_svg( %options )"
Returns an \s-1SVG\s0 string that represents the graph, via as_dot and graphviz.
See as_dot for a list of options.  Must have GraphViz (dot) installed to run.
.SS "as_dot( \e%options )"
.IX Subsection "as_dot( %options )"
Returns a string that is the collation graph expressed in dot
(i.e. GraphViz) format.  Options include:
.IP "\(bu" 4
from
.IP "\(bu" 4
to
.IP "\(bu" 4
color_common
.ie n .SS "path_witnesses( $edge )"
.el .SS "path_witnesses( \f(CW$edge\fP )"
.IX Subsection "path_witnesses( $edge )"
Returns the list of sigils whose witnesses are associated with the given edge.
The edge can be passed as either an array or an arrayref of ( \f(CW$source\fR, \f(CW$target\fR ).
.ie n .SS "readings_at_rank( $rank )"
.el .SS "readings_at_rank( \f(CW$rank\fP )"
.IX Subsection "readings_at_rank( $rank )"
Returns a list of readings at a given rank, taken from the alignment table.
.SS "as_graphml"
.IX Subsection "as_graphml"
Returns a GraphML representation of the collation.  The GraphML will contain 
two graphs. The first expresses the attributes of the readings and the witness 
paths that link them; the second expresses the relationships that link the 
readings.  This is the native transfer format for a tradition.
.SS "as_csv"
.IX Subsection "as_csv"
Returns a \s-1CSV\s0 alignment table representation of the collation graph, one
row per witness (or witness uncorrected.)
.SS "alignment_table"
.IX Subsection "alignment_table"
Return a reference to an alignment table, in a slightly enhanced CollateX
format which looks like this:
.PP
.Vb 6
\& $table = { alignment => [ { witness => "SIGIL", 
\&                             tokens => [ { t => "TEXT" }, ... ] },
\&                           { witness => "SIG2", 
\&                             tokens => [ { t => "TEXT" }, ... ] },
\&                           ... ],
\&            length => TEXTLEN };
.Ve
.SH "NAVIGATION METHODS"
.IX Header "NAVIGATION METHODS"
.ie n .SS "reading_sequence( $first, $last, $sigil, $backup )"
.el .SS "reading_sequence( \f(CW$first\fP, \f(CW$last\fP, \f(CW$sigil\fP, \f(CW$backup\fP )"
.IX Subsection "reading_sequence( $first, $last, $sigil, $backup )"
Returns the ordered list of readings, starting with \f(CW$first\fR and ending
with \f(CW$last\fR, for the witness given in \f(CW$sigil\fR. If a \f(CW$backup\fR sigil is 
specified (e.g. when walking a layered witness), it will be used wherever
no \f(CW$sigil\fR path exists.  If there is a base text reading, that will be
used wherever no path exists for \f(CW$sigil\fR or \f(CW$backup\fR.
.ie n .SS "next_reading( $reading, $sigil );"
.el .SS "next_reading( \f(CW$reading\fP, \f(CW$sigil\fP );"
.IX Subsection "next_reading( $reading, $sigil );"
Returns the reading that follows the given reading along the given witness
path.
.ie n .SS "prior_reading( $reading, $sigil )"
.el .SS "prior_reading( \f(CW$reading\fP, \f(CW$sigil\fP )"
.IX Subsection "prior_reading( $reading, $sigil )"
Returns the reading that precedes the given reading along the given witness
path.
.SS "common_readings"
.IX Subsection "common_readings"
Returns the list of common readings in the graph (i.e. those readings that are
shared by all non-lacunose witnesses.)
.ie n .SS "path_text( $sigil, [, $start, $end ] )"
.el .SS "path_text( \f(CW$sigil\fP, [, \f(CW$start\fP, \f(CW$end\fP ] )"
.IX Subsection "path_text( $sigil, [, $start, $end ] )"
Returns the text of a witness (plus its backup, if we are using a layer)
as stored in the collation.  The text is returned as a string, where the
individual readings are joined with spaces and the meta-readings (e.g.
lacunae) are omitted.  Optional specification of \f(CW$start\fR and \f(CW$end\fR allows
the generation of a subset of the witness text.
.SH "INITIALIZATION METHODS"
.IX Header "INITIALIZATION METHODS"
These are mostly for use by parsers.
.ie n .SS "make_witness_path( $witness )"
.el .SS "make_witness_path( \f(CW$witness\fP )"
.IX Subsection "make_witness_path( $witness )"
Link the array of readings contained in \f(CW$witness\fR\->path (and in 
\&\f(CW$witness\fR\->uncorrected_path if it exists) into collation paths.
Clear out the arrays when finished.
.SS "make_witness_paths"
.IX Subsection "make_witness_paths"
Call make_witness_path for all witnesses in the tradition.
.SS "calculate_ranks"
.IX Subsection "calculate_ranks"
Calculate the reading ranks (that is, their aligned positions relative
to each other) for the graph.  This can only be called on linear collations.
.SS "flatten_ranks"
.IX Subsection "flatten_ranks"
A convenience method for parsing collation data.  Searches the graph for readings
with the same text at the same rank, and merges any that are found.
.ie n .SS "identical_readings =head2 identical_readings( start => $startnode, end => $endnode ) =head2 identical_readings( startrank => $startrank, endrank => $endrank )"
.el .SS "identical_readings =head2 identical_readings( start => \f(CW$startnode\fP, end => \f(CW$endnode\fP ) =head2 identical_readings( startrank => \f(CW$startrank\fP, endrank => \f(CW$endrank\fP )"
.IX Subsection "identical_readings =head2 identical_readings( start => $startnode, end => $endnode ) =head2 identical_readings( startrank => $startrank, endrank => $endrank )"
Goes through the graph identifying all pairs of readings that appear to be
identical, and therefore able to be merged into a single reading. Returns the 
relevant identical pairs. Can be restricted to run over only a part of the 
graph, specified either by node or by rank.
.SS "calculate_common_readings"
.IX Subsection "calculate_common_readings"
Goes through the graph identifying the readings that appear in every witness 
(apart from those with lacunae at that spot.) Marks them as common and returns
the list.
.SS "text_from_paths"
.IX Subsection "text_from_paths"
Calculate the text array for all witnesses from the path, for later consistency
checking.  Only to be used if there is no non-graph-based way to know the
original texts.
.SH "UTILITY FUNCTIONS"
.IX Header "UTILITY FUNCTIONS"
.ie n .SS "common_predecessor( $reading_a, $reading_b )"
.el .SS "common_predecessor( \f(CW$reading_a\fP, \f(CW$reading_b\fP )"
.IX Subsection "common_predecessor( $reading_a, $reading_b )"
Find the last reading that occurs in sequence before both the given readings.
At the very least this should be \f(CW$self\fR\->start.
.ie n .SS "common_successor( $reading_a, $reading_b )"
.el .SS "common_successor( \f(CW$reading_a\fP, \f(CW$reading_b\fP )"
.IX Subsection "common_successor( $reading_a, $reading_b )"
Find the first reading that occurs in sequence after both the given readings.
At the very least this should be \f(CW$self\fR\->end.
.SH "BUGS/TODO"
.IX Header "BUGS/TODO"
.IP "\(bu" 4
Rework \s-1XML\s0 serialization in a more modular way
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software and is provided \*(L"as is\*(R" without express
or implied warranty.  You can redistribute it and/or modify it under
the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tara L Andrews <aurum@cpan.org>
